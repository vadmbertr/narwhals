---
title: "MCMC"
output: html_notebook
---

```{r}
set.seed(15)
```

# Simulation

```{r}
# parameters
A <- 1 / 2
B <- -1 / 4
b <- 1
a <- 0.1
beta <- 0.05
sigma <- 0.1
omega <- 0.01
Delta <- 1
psi <- exp(-Delta * beta)
gamma <- sigma / sqrt(beta)

n <- 500
x <- 1:n

# functions
g <- function (xi, a.arg = a) {
  a.arg * x + xi
}
f <- function (xi, A.arg = A, a.arg = a, B.arg = B, b.arg = b) {
  A.arg * sin(g(xi, a.arg) + b.arg) +
          B.arg * sin(2 * g(xi, a.arg) + 2 * b.arg + pi / 2)
}
rxi <- function (xi, psi.arg = psi, gamma.arg = gamma) {
  for (i in 2:length(xi)) {
    xi[[i]] <- xi[[i - 1]] * psi.arg + rnorm(1, 0, gamma.arg * sqrt((1 - psi.arg^2) / 2))
  }
  return(xi)
}
```

```{r}
plot(A * sin(g(rep(0, n), a) + b), type = "l")
```

```{r}
plot(B * sin(2 * g(rep(0, n), a) + 2 * b + pi / 2), type = "l")
```

```{r}
plot(f(rep(0, n)), type = "l")
```

```{r}
xi <- rxi(rep(0, n))

plot(xi, type = "l")
```

```{r}
Y <- f(xi) + rnorm(n, 0, omega)

plot(Y, type = "l")
```

# Sampling

```{r}
# function
log.lik <- function (xi.arg, omega.arg = omega, psi.arg = psi, gamma.arg = gamma) {
  return(sum(dnorm(Y, f(xi.arg), omega.arg, log = TRUE)) +
         sum(dnorm(xi.arg[2:length(xi.arg)], xi.arg[1:(length(xi.arg) - 1)] * psi.arg,
                   gamma.arg * sqrt((1 - psi.arg^2) / 2), log = TRUE)))
}
```

## All process

```{r}
M <- 250000
delta <- .005
delta.all <- rep(0, M)
delta.ar <- 0.001

xi.mcmc <- matrix(nrow = M, ncol = n)
xi.c <- rnorm(n, 0, .1)
accepted.n <- 0
accepted.all <- rep(0, M)
accepted.rate.all <- rep(0, M)
acceptance.target <- .23

for (k in 1:M) {
  xi.p <- xi.c + rnorm(n, 0, delta)
  log.prob <- min(1, log.lik(xi.p) - log.lik(xi.c))
  if (log(runif(1)) < log.prob) {
    xi.c <- xi.p
    accepted.all[[k]] <- 1
    accepted.n <- accepted.n + 1
  }
  xi.mcmc[k, ] <- xi.c

  # adaptative variance
  acceptance.rate <- accepted.n / k
  accepted.rate.all[[k]] <- acceptance.rate
  delta.all[[k]] <- delta
  if (acceptance.rate < acceptance.target * (1 - .1)) {
    delta <- delta * (1 - delta.ar)
  } else if (acceptance.rate > acceptance.target * (1 + .1)) {
    delta <- delta * (1 + delta.ar)
  }
}

plot(xi, type = "l", col = "blue",
     ylim = c(min(min(xi.mcmc[nrow(xi.mcmc), ]), min(xi)), max(max(xi.mcmc[nrow(xi.mcmc), ]), max(xi))))
lines(xi.mcmc[nrow(xi.mcmc), ], type = "l", col = "red")
```

```{r}
print(acceptance.rate)
```

```{r}
plot(accepted.rate.all, type = "l")
abline(h = acceptance.target, lty = "dashed", col = "red")
```

```{r}
plot(delta.all, type = "l")
```

```{r}
plot(Y, type = "l", col = "blue")
lines(f(xi.mcmc[nrow(xi.mcmc), ]), type = "l", col = "red")
```

## Per process unit

```{r}
M <- 500
delta <- rep(.05, n)
delta.ar <- 0.01

xi.mcmc <- matrix(nrow = M, ncol = n)
xi.c <- rnorm(n, 0, .1)
accepted.n <- rep(0, n)
acceptance.rate <- rep(0, n)
acceptance.target <- .23

for (k in 1:M) {
  for (i in 1:n) {
    xi.p <- xi.c
    xi.p[[i]] <- rnorm(1, xi.p[[i]], delta[[i]])
    log.prob <- min(1, log.lik(xi.p) - log.lik(xi.c))
    if (log(runif(1)) < log.prob) {
      xi.c <- xi.p
      accepted.n[[i]] <- accepted.n[[i]] + 1
    }

    # adaptative variance
    acceptance.rate[[i]] <- accepted.n[[i]] / k
    if (acceptance.rate[[i]] < acceptance.target * (1 - .1)) {
      delta[[i]] <- delta[[i]] * (1 - delta.ar)
    } else if (acceptance.rate[[i]] > acceptance.target * (1 + .1)) {
      delta[[i]] <- delta[[i]] * (1 + delta.ar)
    }
  }
  xi.mcmc[k, ] <- xi.c
}

plot(xi, type = "l", col = "blue",
     ylim = c(min(min(xi.mcmc[nrow(xi.mcmc), ]), min(xi)), max(max(xi.mcmc[nrow(xi.mcmc), ]), max(xi))))
lines(xi.mcmc[nrow(xi.mcmc), ], type = "l", col = "red")
```

```{r}
plot(acceptance.rate)
abline(h = acceptance.target, lty = "dashed", col = "red")
```

```{r}
plot(delta)
```

```{r}
plot(Y, type = "l", col = "blue")
lines(f(xi.mcmc[nrow(xi.mcmc), ]), type = "l", col = "red")
```
