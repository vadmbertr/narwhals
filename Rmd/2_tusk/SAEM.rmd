---
title: "Sinusoidal model"
author: "Adeline Leclercq Samson"
date: "2023-01-11"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
set.seed(15)

library(ggplot2)
```

## Description of the sinusoidal model

The observations along the tusk are denoted $Y_i$ for $i=1, \ldots, n$, with the corresponding  position along the tusk  denoted $x_i$.
The model is the following
$$Y_i = f(x_i, \varphi)+\varepsilon_i $$
with $\varepsilon_i$ a  random noise assumed to be normally distributed with mean $0$ and variance $\omega^2$.
The regression function is a periodic sinusoidal function
$$f(x, \varphi) = A \sin(g(x)+b) + B\sin(2g(x)+2b+\pi/2) $$
with function $g$ defined as
$$ g(x) = ax+\xi_x$$
and finally $\xi_x$ is assumed to be a random Ornstein-Uhlenbeck process 
$$d\xi_x = -\beta \xi_xdx+\sigma dW_x $$

The objective is to estimate the parameters $\varphi = (A,B,a,b)$; $\psi = e^{\beta\Delta}$ where $\Delta$ is the step size between two observations and $\gamma^2 = \frac{\sigma^2}{2\beta}(1-e^{-2\beta\Delta})$. 

## Simulation of trajectories

Let us start with some simulations.
```{r}
# parameters
A <- 1 / 2
B <- -1 / 4
b <- 1
a <- 0.1
beta <- 0.05
sigma <- 0.1
omega <- 0.01
delta <- 1
psi <- exp(-delta * beta)
gamma <- sigma / sqrt(2 * beta) * sqrt(1 - psi^2)

n <- 500
x <- 1:n

# functions
g <- function (xi, a.arg = a) {
  a.arg * x + xi
}
f <- function (xi, A.arg = A, a.arg = a, B.arg = B, b.arg = b) { 
  A.arg * sin(g(xi, a.arg) + b.arg) +
          B.arg * sin(2 * g(xi, a.arg) + 2 * b.arg + pi / 2)
}
rxi <- function (xi=rep(0,n), psi.arg = psi, gamma.arg = gamma) {
  for (i in 2:length(xi)) {
    xi[[i]] <- xi[[i - 1]] * psi.arg + rnorm(1, 0, gamma.arg)
  }
  return(xi)
}

xi <- rxi(rep(0, n))
Y <- f(xi) + rnorm(n, 0, omega)
```

```{r}
plot(A * sin(g(rep(0, n), a) + b), type = "l")
```

```{r}
plot(B * sin(2 * g(rep(0, n), a) + 2 * b + pi / 2), type = "l")
```

```{r}
plot(f(rep(0, n)), type = "l")
```

```{r}
plot(xi, type = "l")
```

```{r}
plot(Y, type = "l")
```

## Estimation with the EM algorithm

The EM algorithm is based on the complete log-likelihood of the model.
The solution of the hidden process $\xi_x$ is
$$\xi_{x+\Delta} = \xi_x e^{-\beta\Delta} + \int_{x}^{x+\Delta} \sigma e^{\beta(s-x)}dW_s $$
such that the transition density is
$$p(\xi_{x+\delta}|\xi_x) = \mathcal{N}(\xi_x e^{-\beta\Delta}, \frac{\sigma^2}{2\beta}(1-e^{-2\beta\Delta}))$$

The complete log-likelihood is thus
\begin{eqnarray*}
\log L(Y,\xi,\theta)&=&\sum_{i=1}^n\log p(Y_i|\xi_i) +\sum_{i=1}^n\log p(\xi_{i}|\xi_{i-1}) +\log p(\xi_1)\\
&=& -\sum_{i=1}^n \frac{(Y_i-f(x_i, \varphi))^2}{2\omega^2}-\frac{n}{2}\log(\omega^2)\\
&&- \sum_{i=1}^n\frac{(\xi_i-\xi_{i-1}e^{-\beta\Delta})^2}{\frac{\sigma^2}{\beta}(1-e^{-2\beta\Delta})} - \frac{n}{2}\log(\frac{\sigma^2}{2\beta}(1-e^{-2\beta\Delta})) \\
&=& -\sum_{i=1}^n \frac{(Y_i-f(x_i, \varphi))^2}{2\omega^2}-\frac{n}{2}\log(\omega^2)\\
&&- \sum_{i=1}^n\frac{(\xi_i-\xi_{i-1}\psi)^2}{2\gamma^2} - \frac{n}{2}\log(\gamma^2) 
\end{eqnarray*}

The EM algorithm proceeds at iteration $k$ with the two following steps, given the current value of the parameters $\theta^k$

- E step: calculation of $Q(\theta, \theta^k)$
- M step: update of the parameters $\theta^{k+1}=\arg\max_\theta Q(\theta, \theta^k)$

### E step

The condition distribution $p(\xi|Y; \theta^k)$ is not explicit because the regression function is not linear. We should proceed with a MCMC algorithm to sample from this distribution. This will lead to a stochastic version of the EM algorithm, namely the SAEM algorithm.

### M step

We need the sufficient statistics to update the algorithm. 

The statistics are


\begin{eqnarray*}
S_1(\xi_i)& =& \frac{1}{n}\sum_{i=1}^n (Y_i -f(x_i(\xi_i), \varphi))^2\\
S_2(\xi_i) &=& \sum_{i=1}^n \xi_{i-1}\xi_i\\
S_3(\xi_i) &=& \sum_{i=1}^n \xi_{i-1}^2\\
S_4(\xi_i) &=& \sum_{i=1}^n \xi_i^2
\end{eqnarray*}


The update of the parameters are based on these statistics. 

### SAEM algorithm

The steps of the SAEM algorithm are

- E step: simulation of a new trajectory $\xi^k$ with a MCMC algorithm targeting $p(\xi|Y; \theta^k)$ as stationary distribution

- SA step: stochastic approximation of the sufficient statistics

\begin{eqnarray*}
s_1^k &=& s_1^{k-1} + (1-\alpha_k)(S_1(\xi^k)-s_1^{k-1}) \\
s_2^k &=& s_2^{k-1} + (1-\alpha_k)(S_2(\xi^k)-s_2^{k-1}) \\
s_3^k &=& s_3^{k-1} + (1-\alpha_k)(S_3(\xi^k)-s_3^{k-1}) \\
s_4^k &=& s_4^{k-1} + (1-\alpha_k)(S_4(\xi^k)-s_4^{k-1}) \\
\end{eqnarray*}

- M step: update of $\theta^{k}$ using the sufficient statistics $s^k$

\begin{eqnarray*}
\widehat{\varphi}^k &=& \arg\min_\varphi \sum_{i=1}^n \left(y_i - f(x_i(\xi_i^k), \varphi)\right)^2
\\
\widehat{\psi}^k &=& \frac{s_2^k}{s_3^k}\\
\widehat{\omega^{2}}^k &=& s_1^k\\
\widehat{\gamma^{2}}^k &=& \frac{1}{n}(\widehat{\psi^2}^ks_3^k-2\widehat{\psi}^ks_2^k+s_4^k)
\end{eqnarray*}


#### MCMC

```{r}
acceptance.target <- .23
delta.ar <- 0.1

# functions
mcmc.log.lik <- function (xi.arg, omega.arg, psi.arg, gamma.arg,A.arg,B.arg,b.arg,a.arg) { #TODO : add A, B, a, b 
  return(sum(dnorm(Y, f(xi.arg,A.arg,B.arg=B.arg,b.arg=b.arg,a.arg=a.arg), omega.arg, log = TRUE)) +
         sum(dnorm(xi.arg[2:length(xi.arg)], xi.arg[1:(length(xi.arg) - 1)] * psi.arg,
                   gamma.arg, log = TRUE))) #TODO : add A, B, a, b 
}

mcmc.init <- function (n.rep) {
  return(list(xi = matrix(nrow = n.rep, ncol = n),
              xi.p = matrix(nrow = n.rep, ncol = n),
              delta = matrix(nrow = n.rep, ncol = n),
              acceptance.rate = matrix(nrow = n.rep, ncol = n),
              xi.c = rep(0, n),
              delta.c = rep(.05, n),
              accepted.n = rep(0, n),
              n.it = 0))
}

mcmc.alg <- function (n.rep, mcmc.arg = NULL, omega.arg = omega, psi.arg = psi, gamma.arg = gamma, A.arg = A,B.arg=B,b.arg=b,a.arg=a) {#TODO : add A, B, a, b 
  if (is.null(mcmc.arg)) {
    mcmc.arg <- mcmc.init(n.rep)
  }

  for(j in 1:n.rep) {
    mcmc.arg$n.it <- mcmc.arg$n.it + 1
    for (i in 1:n) {
      xi.p <- mcmc.arg$xi.c
      xi.p[[i]] <- rnorm(1, xi.p[[i]], mcmc.arg$delta.c[[i]])
      mcmc.arg$xi.p[mcmc.arg$n.it, i] <- xi.p[[i]]
      log.prob <- min(1, mcmc.log.lik(xi.p, omega.arg, psi.arg, gamma.arg,A.arg,B.arg,b.arg,a.arg) -
                            mcmc.log.lik(mcmc.arg$xi.c, omega.arg, psi.arg, gamma.arg,A.arg,B.arg,b.arg,a.arg)) #TODO : add A, B, a, b  x 2
      if (log(runif(1)) < log.prob) {
        mcmc.arg$xi.c <- xi.p
        mcmc.arg$accepted.n[[i]] <- mcmc.arg$accepted.n[[i]] + 1
      }

      mcmc.arg$acceptance.rate[mcmc.arg$n.it, i] <- mcmc.arg$accepted.n[[i]] / mcmc.arg$n.it
      if (mcmc.arg$acceptance.rate[mcmc.arg$n.it, i] < acceptance.target * (1 - .1)) {
        mcmc.arg$delta.c[[i]] <- mcmc.arg$delta.c[[i]] * (1 - delta.ar)
      } else if (mcmc.arg$acceptance.rate[mcmc.arg$n.it, i] > acceptance.target * (1 + .1)) {
        mcmc.arg$delta.c[[i]] <- mcmc.arg$delta.c[[i]] * (1 + delta.ar)
      }
    }
    mcmc.arg$xi[mcmc.arg$n.it, ] <- mcmc.arg$xi.c
    mcmc.arg$delta[mcmc.arg$n.it, ] <- mcmc.arg$delta.c
  }

  return(mcmc.arg)
}
```

```{r}
M <- 150
mcmc.obj <- mcmc.alg(M,A.arg=A,B.arg=B,b.arg=b,a.arg=a)#TODO : add A, B, a, b 
```

**Tirage**

```{r}
plot(xi, type = "l", col = "blue",
     ylim = c(min(min(mcmc.obj$xi.c), min(xi)), max(max(mcmc.obj$xi.c), max(xi))))
lines(mcmc.obj$xi.c, type = "l", col = "red")

plot(Y, type = "l", col = "blue")
lines(f(mcmc.obj$xi.c), type = "l", col = "red")
```

```{r}
plot(mcmc.obj$acceptance.rate[mcmc.obj$n.it, ])
abline(h = acceptance.target, lty = "dashed", col = "red")
```

*Ecarts*

```{r}
worst.idx <- which.max(abs(xi - mcmc.obj$xi.c))
ggplot(data = data.frame(x = 1:M), aes(x = x)) +
        geom_line(aes(y = mcmc.obj$xi[, worst.idx]), color = "blue") +
        geom_line(aes(y = mcmc.obj$xi.p[, worst.idx]), color = "red") +
        geom_hline(aes(yintercept = xi[[worst.idx]])) +
        ylab("Y")

best.idx <- which.min(abs(xi - mcmc.obj$xi.c))
ggplot(data = data.frame(x = 1:M), aes(x = x)) +
        geom_line(aes(y = mcmc.obj$xi[, best.idx]), color = "blue") +
        geom_line(aes(y = mcmc.obj$xi.p[, best.idx]), color = "red") +
        geom_hline(aes(yintercept = xi[[best.idx]])) +
        ylab("Y")

farest.idx <- which.max(abs(xi))
ggplot(data = data.frame(x = 1:M), aes(x = x)) +
        geom_line(aes(y = mcmc.obj$xi[, farest.idx]), color = "blue") +
        geom_line(aes(y = mcmc.obj$xi.p[, farest.idx]), color = "red") +
        geom_hline(aes(yintercept = xi[[farest.idx]])) +
        ylab("Y")
```

```{r}
coeff <- max(mcmc.obj$acceptance.rate[, worst.idx]) / max(mcmc.obj$delta[, worst.idx])
ggplot(data = data.frame(x = 1:M), aes(x = x)) +
        geom_line(aes(y = mcmc.obj$acceptance.rate[, worst.idx]), color = "red") +
        geom_line(aes(y = mcmc.obj$delta[, worst.idx] * coeff), color = "blue") +
        geom_hline(aes(yintercept = acceptance.target * 1.1), linetype = 2, color = "red") +
        geom_hline(aes(yintercept = acceptance.target * .9), linetype = 2, color = "red") +
        scale_y_continuous(name = "Acceptance rate", sec.axis = sec_axis(~. / coeff, name = "Delta"))

coeff <- max(mcmc.obj$acceptance.rate[, best.idx]) / max(mcmc.obj$delta[, best.idx])
ggplot(data = data.frame(x = 1:M), aes(x = x)) +
        geom_line(aes(y = mcmc.obj$acceptance.rate[, best.idx]), color = "red") +
        geom_line(aes(y = mcmc.obj$delta[, best.idx] * coeff), color = "blue") +
        geom_hline(aes(yintercept = acceptance.target * 1.1), linetype = 2, color = "red") +
        geom_hline(aes(yintercept = acceptance.target * .9), linetype = 2, color = "red") +
        scale_y_continuous(name = "Acceptance rate", sec.axis = sec_axis(~. / coeff, name = "Delta"))
```

*xi au fil des k*

```{r}
par(mfrow = c(2, 2))
for(k.ind in round(seq(1, M, length.out = 10))) {
  plot(xi, type = "l", col = "blue",
       ylim = c(min(min(mcmc.obj$xi[k.ind, ]), min(xi)), max(max(mcmc.obj$xi[k.ind, ]), max(xi))),
       main = paste("k=", k.ind))
  lines(mcmc.obj$xi[k.ind, ], type = "l", col = "red")
}
```

*f au fil des k*

```{r}
par(mfrow = c(2, 2))
for(k.ind in round(seq(1, M, length.out = 10))) {
  plot(Y, type = "l", col = "blue",
       main = paste("k=", k.ind))
  lines(f(mcmc.obj$xi[k.ind, ]), type = "l", col = "red")
}
```

**Identifiabilité**

```{r}
p1 <- rxi()
p2 <- rxi()
p3 <- rxi()
p4 <- rxi()

par(mfrow = c(2, 2))

plot(p1, type = "l", col = 1)

plot(p1, type = "l", col = 1, ylim = c(min(c(min(p1), min(p2))), max(c(max(p1), max(p2)))))
lines(p2, type = "l", col = 2)

plot(p1, type = "l", col = 1, ylim = c(min(c(min(p1), min(p3))), max(c(max(p1), max(p3)))))
lines(p3, type = "l", col = 3)

plot(p1, type = "l", col = 1, ylim = c(min(c(min(p1), min(p4))), max(c(max(p1), max(p4)))))
lines(p4, type = "l", col = 4)
```

```{r}
par(mfrow = c(2, 2))

plot(f(p1), type = "l", col = 1)

plot(f(p1), type = "l", col = 1)
lines(f(p2), type = "l", col = 2)

plot(f(p1), type = "l", col = 1)
lines(f(p3), type = "l", col = 3)

plot(f(p1), type = "l", col = 1)
lines(f(p4), type = "l", col = 4)
```

```{r}
par(mfrow = c(2, 2))
plot(Y, type = "l", col = 1, main="goal")

plot(Y, type = "l", col = 1, main="MCMC")
lines(f(mcmc.obj$xi.c), type = "l", col = 2)

plot(Y, type = "l", col = 1, main="xi simulation")
lines(f(mcmc.obj$xi.c), type = "l", col = 2)
lines(f(p1), type = "l", col = 3)

plot(Y, type = "l", col = 1, main="xi simulation")
lines(f(mcmc.obj$xi.c), type = "l", col = 2)
lines(f(p2), type = "l", col = 4)
```

#### EM

```{r}
saem.alg <- function (n.rep = 500, n.mcmc = 20, n.alpha = 90) {
  s1.c <- 0
  s1 <- rep(s1.c, n.rep)
  s2.c <- 0
  s2 <- rep(s2.c, n.rep)
  s3.c <- 0
  s3 <- rep(s3.c, n.rep)
  s4.c <- 0
  s4 <- rep(s4.c, n.rep)

  omega.c <- .5
  omega <- rep(omega.c, n.rep)
  psi.c <- .5
  psi <- rep(psi.c, n.rep)
  gamma.c <- .5
  gamma <- rep(gamma.c, n.rep)
  
  A.c <- .7
  A <- rep(A.c, n.rep)
  
  a.c <- 0
  a <- rep(a.c, n.rep)
  
  
  B.c <- 0.2 
  B <- rep(B.c, n.rep)
  
  b.c <- 0 
  b <- rep(b.c, n.rep)
  
  #TODO : add A, B, a, b 
  
  mcmc.rep <- rep(5, n.rep)
  mcmc.rep[n.mcmc:n.rep] <- 1

  alpha <- rep(1, n.rep)
  alpha[n.alpha:n.rep] <- 1 / ((1:(n.rep - n.alpha + 1))^0.8)

  mcmc.obj <- mcmc.init(sum(mcmc.rep))
  
  for (k in 1:n.rep) {
    # MCMC
    mcmc.obj <- mcmc.alg(mcmc.rep[[k]], mcmc.obj, omega.c, psi.c, gamma.c,A.c,B.c,b.c,a.c) #TODO : add A, B, a, b 

    # E
    S1 <- mean((Y - f(mcmc.obj$xi.c,A.arg=A.c,B.arg=B.c,b.arg=b.c,a.arg=a.c))^2)  # TODO: add A, B, a, b
    S2 <- sum(mcmc.obj$xi.c[1:(n - 1)] * mcmc.obj$xi.c[2:n])
    S3 <- sum(mcmc.obj$xi.c[1:(n - 1)]^2)
    S4 <- sum(mcmc.obj$xi.c[2:n]^2)

    # SA
    s1.c <- s1.c + alpha[[k]] * (S1 - s1.c)
    s2.c <- s2.c + alpha[[k]] * (S2 - s2.c)
    s3.c <- s3.c + alpha[[k]] * (S3 - s3.c)
    s4.c <- s4.c + alpha[[k]] * (S4 - s4.c)
    s1[[k]] <- s1.c
    s2[[k]] <- s2.c
    s3[[k]] <- s3.c
    s4[[k]] <- s4.c

    # M
    omega.c <- sqrt(s1.c)
    psi.c <- s2.c / s3.c
    gamma.c <- sqrt((psi.c^2 * s3.c - 2 * psi.c * s2.c + s4.c) / n)
    #calcul de phi 
    f.inter<-function(A,B,b,a){
      return (f(mcmc.obj$xi.c,A.arg=A,B.arg=B,b.arg=b,a.arg=a)) #TODO : add A, B, a, b 
    }
    pb <- nls(Y~f.inter(A,B,b,a), start = list(A=0,B=0.1,b=0.3,a=0.2)) #TODO : add A, B, a, b 
    A.c <- coef(pb)[1]
    B.c <- coef(pb)[2]
    b.c <- coef(pb)[3]
    a.c <- coef(pb)[4]
    

    #TODO : add A, B, a, b 
    
    omega[[k]] <- omega.c
    psi[[k]] <- psi.c
    gamma[[k]] <- gamma.c
    A[[k]]<-A.c
    B[[k]]<-B.c
    b[[k]]<-b.c
    a[[k]]<-a.c
    
    
    #TODO : add A, B, a, b 
  }

  return(list(mcmc = mcmc.obj,
              s1.c = s1.c, s2.c = s2.c, s3.c = s3.c, s4.c = s4.c,
              s1 = s1, s2 = s2, s3 = s3, s4 = s4,
              omega.c = omega.c, psi.c = psi.c, gamma.c = gamma.c,A.c=A.c,B.c=B.c,b.c=b.c,a.c=a.c,
              omega = omega, psi = psi, gamma = gamma,A=A,B=B,b=b,a=a)) #TODO : add A, B, a, b 
}
```

```{r}
saem.obj <- saem.alg()
```

```{r}
plot(xi, type = "l", col = "blue",
     ylim = c(min(min(saem.obj$mcmc$xi.c), min(xi)), max(max(saem.obj$mcmc$xi.c), max(xi))))
lines(saem.obj$mcmc$xi.c, type = "l", col = "red")

plot(Y, type = "l", col = "blue")
lines(f(saem.obj$mcmc$xi.c), type = "l", col = "red")
```

```{r}
par(mfrow = c(2, 2))

plot(saem.obj$omega, type = 'l', col = 'blue', main = "Omega",ylim=c(min(c(saem.obj$omega,omega)),max(saem.obj$omega,omega)))
abline(h = omega, col = 'red')

plot(saem.obj$psi, type = 'l', col = 'blue', main = "Psi",ylim=c(min(c(saem.obj$psi,psi)),max(saem.obj$psi,psi)))
abline(h = psi, col = 'red')

plot(saem.obj$gamma, type = 'l', col = 'blue', main = "gamma",ylim=c(min(c(saem.obj$gamma,gamma)),max(saem.obj$gamma,gamma)))
abline(h = gamma, col = 'red')

plot(saem.obj$A, type = 'l', col = 'blue', main = "A",ylim=c(min(c(saem.obj$A,A)),max(saem.obj$A,A)))
abline(h = A, col = 'red')

plot(saem.obj$B, type = 'l', col = 'blue', main="B",ylim=c(min(c(saem.obj$B,B)),max(saem.obj$B,B)))
abline(h = B, col = 'red')

plot(saem.obj$b, type = 'l', col = 'blue', main="b",ylim=c(min(c(saem.obj$b,b)),max(saem.obj$b,b)))
abline(h = b, col = 'red')

plot(saem.obj$a, type = 'l', col = 'blue', main="a",ylim=c(min(c(saem.obj$a,a)),max(saem.obj$a,a)))
abline(h = a, col = 'red')
```


```{r}
r<-3
omega.vec<-rep(0,r)
gamma.vec<-rep(0,r)
psi.vec<-rep(0,r)


for (w in 1:r){
  saem.obj <- saem.alg()
  omega.vec[w]<-saem.obj$omega.c
  psi.vec[w]<-saem.obj$psi.c
  gamma.vec[w]<-saem.obj$gamma.c
}



gamma.err<-(gamma-gamma.vec)/gamma
psi.err<-(psi-psi.vec)/psi
omega.err<-(omega-omega.vec)/omega

par(mfrow=c(1,3))
boxplot(gamma.err,main="Gamma")
abline(h = mean(gamma.err), col = "red")
abline(h = 0, col = "blue")
boxplot(psi.err,main="Psi")
abline(h = mean(psi.err), col = "red")
abline(h = 0, col = "blue")
boxplot(omega.err,main="Omega")
abline(h = mean(omega.err), col = "red")
abline(h = 0, col = "blue")
```

